---
description: "Golang Coding Standards for the version CLI utility project"
globs: **/*.go
alwaysApply: true
---

# Golang Coding Standards:

- Use 4 spaces for indentation
- Maximum line length of 120 characters
- Follow golang naming conventions
- Use descriptive variable and function names
- Add docstrings for all functions and classes
- Imports in order: standard library, third-party, local application
- Use type hints for function parameters and return values

## 0) Scope & Goals

* Language: Go ≥ 1.22 (or project-specified).
* Targets: linux/darwin/windows (amd64/arm64). CGO disabled unless justified.
* Principles: clarity > cleverness, correctness > micro-perf, minimal deps, deterministic builds.

## 1) Project Layout

* **Module path** must match VCS location.
* **Packages**:

  * `cmd/<app>/main.go` — CLI entrypoint, flag parsing, glue only.
  * `internal/...` — core logic split by concerns (e.g., `internal/parse`, `internal/sort`, `internal/git`, `internal/buildinfo`).
  * `pkg/...` — only for stable, external-facing APIs (avoid unless needed).
  * `docs/` — user/developer docs; ADRs in `docs/adr`.
  * `bin/` — built artifacts only.
* Keep package APIs small and focused; avoid circular deps; no import cycles.

## 2) Formatting, Linting, Tooling

* **Formatting**: `gofmt -s`, `goimports` mandatory.
* **Linting**: `golangci-lint` with at least:

  * `errcheck, gosimple, govet, ineffassign, staticcheck, unconvert, unparam, whitespace, misspell, prealloc (suggest), gocritic (default set)`.
* **Build flags**: prefer `-trimpath`; set `-ldflags="-s -w …"` for release.
* **No generated code without a generator note**:

  * Add `// Code generated by <tool>; DO NOT EDIT.` and a `go:generate` line.

## 3) Naming & Structure

* Exported identifiers **must** have doc comments: `// Foo …`.
* Package names: lower\_snake, short, meaningfully generic (`parse`, `sorter`, `git`), **no** `util`/`helpers` buckets.
* Keep functions < \~60 lines where reasonable; extract helpers when logic branches.

## 4) Errors

* **No panics** in normal flow. Use `panic` only in truly unrecoverable init failures.
* Wrap errors with context:

  ```go
  if err != nil { return fmt.Errorf("opening index %q: %w", path, err) }
  ```
* Prefer sentinel errors + `errors.Is/As` when branching by error kind.
* User-facing CLI errors go to **stderr**; machine output goes to **stdout**.
* Do not hide errors; avoid returning `nil` error with partial work.

## 5) Context & Cancellation

* Every long-running / I/O / network function accepts `context.Context` as the **first** param.
* Respect `ctx.Done()`; propagate deadlines/timeouts; never store contexts in structs.
* Top-level `main` derives a root `ctx` and cancels on signals.

## 6) Concurrency

* Prefer `errgroup`/`context` over manual `WaitGroup` + channels.
* Avoid shared mutable state; if needed, guard with `sync.Mutex`.
* No goroutine leaks: ensure all goroutines finish on context cancel.
* Channels: buffered when appropriate; close from sender only.

## 7) I/O, Files, Paths

* Use `os`, `io`, `bufio`, `fs` idiomatically (`defer f.Close()` immediately).
* **Cross-platform paths**: always `filepath.*` (never hardcode `/` or `\`).
* Handle CRLF: treat input as binary unless text semantics are required.
* Large inputs: stream (scanner/reader) rather than loading whole file if feasible.

## 8) CLI UX (Apps in `cmd/...`)

* Flags via `flag` or `cobra` (project decision). Defaults must be safe.
* **Exit codes**:

  * `0` success; `1` user error/invalid input; `>1` system/IO errors.
* Stdout reserved for machine-parsable results (when applicable). Human messages → stderr.
* `--help` must work and not exit with error.
* Deterministic output ordering; no color unless `isatty` and explicitly requested.

## 9) Logging

* For small CLIs, prefer quiet by default:

  * `-v/--verbose` → human logs to stderr.
  * `-q/--quiet` → suppress non-essential diagnostics.
* No global loggers; pass logger or use scoped helpers if needed.

## 10) Data & Serialization

* JSON: define structs with explicit `json:"..."` tags; avoid `map[string]any` unless schema-free.
* Stable key order when hashing/signing; document compatibility guarantees.
* Avoid floating-point for IDs/versions; use strings/ints.

## 11) APIs & Interfaces

* Depend on interfaces **you own** (define in consumer package) rather than vendor’s.
* Small interfaces (1–3 methods).
* Return concrete types; accept interfaces.

## 12) Dependencies

* Prefer standard library. Any third-party dependency must be justified (size, license, stability).
* Pin versions; update deliberately.
* No transitive heavy frameworks for trivial tasks.

## 13) Performance & Memory

* Optimize only after measurement; add benchmarks for hot paths.
* Avoid gratuitous allocations; reuse buffers with care.
* Use `strings.Builder`, `bytes.Buffer` for concatenations.

## 14) Testing

* **Unit tests**: table-driven, fast, deterministic.
* **Coverage focus**: parsing/ordering logic, error paths, CLI glue.
* Use `t.Run` subtests; avoid sleeps/time-based flakiness.
* **Golden tests** for stable textual outputs (keep fixtures in `testdata/`).
* **Benchmarks** for sorting on large sets (10k+ versions).
* Use `-race` in CI: `go test ./... -race`.
* Do not rely on network/filesystem unless explicitly marked as integration.

## 15) Time, Random, Env

* Time: pass in a clock interface for determinism in tests (or inject `time.Now`).
* Random: seed deterministically in tests; never rely on global PRNG state.
* Env: read once at init/entry and pass values down; allow overriding via flags.

## 16) Security & Safety

* No secrets in code or logs.
* Validate all external inputs; sanitize file names/paths.
* Use strict file modes for created files (`0600` when containing sensitive info).

## 17) Cross-Platform Notes (Windows/Linux/macOS)

* File permissions: tolerate platforms ignoring POSIX bits (Windows).
* Paths and encodings: UTF-8 assumption; handle CRLF gracefully.
* External tools (e.g., `git`): discover via `exec.LookPath`; allow override via env/flag.

## 18) Documentation

* **Every exported symbol** has a GoDoc comment.
* `README.md` includes: purpose, quickstart, install (Scoop/Linux), examples, exit codes.
* Keep `docs/Project-specification.md` as the **single source of truth** for spec; update when behavior changes.
* Maintain CHANGELOG with Conventional Commits categories.

## 19) Git, Commits, PRs

* Use **Conventional Commits**: `feat:`, `fix:`, `chore:`, `docs:`, `refactor:`, `test:`, `build:`, `ci:`.
* Small, reviewable PRs; each PR references updated docs and, when applicable, ADR/MPC entries.
* Tag releases with SemVer `vX.Y.Z` only from green CI.

## 20) Build & Release (summary)

* Reproducible builds via GoReleaser; CGO off; `-trimpath`.
* Artifacts go to `bin/` (local builds) and release archives (CI).
* Windows: Scoop manifest; Linux: tar.gz + `install.sh`.
* Publish checksums; verify in CI.

## 21) Example Patterns

### Error wrapping & sentinel

```go
var ErrInvalidVersion = errors.New("invalid version")

func ParseVersion(s string) (V, error) {
    v, err := parseCore(s)
    if err != nil {
        return V{}, fmt.Errorf("%w: %q: %v", ErrInvalidVersion, s, err)
    }
    return v, nil
}

if errors.Is(err, ErrInvalidVersion) { /* print user hint */ }
```

### Table-driven test

```go
func TestOrder(t *testing.T) {
    cases := []struct{
        in  []string
        out []string
    }{
        {[]string{"0.10.0","0.9.0"}, []string{"0.9.0","0.10.0"}},
    }
    for _, tt := range cases {
        got := Sort(tt.in)
        if !slices.Equal(got, tt.out) {
            t.Fatalf("want %v, got %v", tt.out, got)
        }
    }
}
```

### Context-aware command

```go
ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
defer stop()
if err := run(ctx, os.Args[1:]); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
}
```

## 22) Definition of Done (Go)

* Lint + tests (with `-race`) pass in CI.
* CLI help accurate; exit codes correct.
* Cross-platform path/FS logic verified.
* Docs updated (`README`, `docs/Project-specification.md`, ADR if needed).
* MPC updated when behavior/rules change.
* GoReleaser dry-run OK.


These standards ensure readability and consistency throughout our codebase.